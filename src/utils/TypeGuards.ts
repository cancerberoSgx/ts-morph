// dprint-ignore-file
// -----------------------
// WARNING - DO NOT modify the "is" methods of the TypeGuards class directly. It is code generated by createTypeGuardsUtility.ts
//
// Note: This file is excluded from code coverage reports because it's automatically maintained (low risk).
// -----------------------

import * as compiler from "../compiler";
import { SyntaxKind } from "../typescript";
import { Structure } from "../structures";
import { KindToNodeMappings } from "../compiler";
import { Token } from 'typescript';

/**
 * Type guards for checking the type of a node.
 */
export class TypeGuards {
    private constructor() {
    }

    /**
     * Gets if the node has an expression.
     * @param node - Node to check.
     */
    static hasExpression<T extends compiler.Node>(node: T): node is T & { getExpression(): compiler.Expression; } {
        // this method is manually maintained
        if ((node as any).getExpression == null)
            return false;
        return (node as any).getExpression() != null;
    }

    /**
     * Gets if the node has a name.
     * @param node - Node to check.
     */
    static hasName<T extends compiler.Node>(node: T): node is T & { getName(): string; getNameNode(): compiler.Node; } {
        // this method is manually maintained
        if ((node as any).getName == null)
            return false;
        return typeof (node as any).getName() === "string";
    }

    /**
     * Gets if the node has a body.
     * @param node - Node to check.
     */
    static hasBody<T extends compiler.Node>(node: T): node is T & { getBody(): compiler.Node; } {
        // this method is manually maintained
        if ((node as any).getBody == null)
            return false;
        return (node as any).getBody() != null;
    }

    /**
     * Creates a type guard for syntax kinds.
     */
    static is<TKind extends keyof KindToNodeMappings>(kind: TKind): (node: compiler.Node) => node is KindToNodeMappings[TKind] {
        return (node: compiler.Node): node is KindToNodeMappings[TKind] => {
            return node.getKind() == kind;
        };
    }

    /**
     * Gets if the provided value is a Node.
     */
    static isNode(value: unknown): value is compiler.Node {
        return value != null && (value as any).compilerNode != null
    }

    /**
     * Gets if the provided node is a comment node.
     */
    static isCommentNode(node: compiler.Node): node is compiler.CommentStatement | compiler.CommentClassElement | compiler.CommentTypeElement | compiler.CommentObjectLiteralElement | compiler.CommentEnumMember {
        const kind = node.getKind();
        return kind === SyntaxKind.SingleLineCommentTrivia || kind === SyntaxKind.MultiLineCommentTrivia;
    }

    /**
     * Gets if the provided node is a CommentStatement.
     */
    static isCommentStatement(node: compiler.Node): node is compiler.CommentStatement {
        return (node.compilerNode as compiler.CompilerCommentStatement)._commentKind === compiler.CommentNodeKind.Statement;
    }

    /**
     * Gets if the provided node is a CommentClassElement.
     */
    static isCommentClassElement(node: compiler.Node): node is compiler.CommentClassElement {
        return (node.compilerNode as compiler.CompilerCommentClassElement)._commentKind === compiler.CommentNodeKind.ClassElement;
    }

    /**
     * Gets if the provided value is a CommentTypeElement.
     */
    static isCommentTypeElement(node: compiler.Node): node is compiler.CommentTypeElement {
        return (node.compilerNode as compiler.CompilerCommentTypeElement)._commentKind === compiler.CommentNodeKind.TypeElement;
    }

    /**
     * Gets if the provided node is a CommentObjectLiteralElement.
     */
    static isCommentObjectLiteralElement(node: compiler.Node): node is compiler.CommentObjectLiteralElement {
        return (node.compilerNode as compiler.CompilerCommentObjectLiteralElement)._commentKind === compiler.CommentNodeKind.ObjectLiteralElement;
    }

    /**
     * Gets if the provided node is a CommentEnumMember.
     */
    static isCommentEnumMember(node: compiler.Node): node is compiler.CommentEnumMember {
        return (node.compilerNode as compiler.CompilerCommentEnumMember)._commentKind == compiler.CommentNodeKind.EnumMember;
    }

    /**
     * Gets if the node is an AbstractableNode.
     * @param node - Node to check.
     */
    static isAbstractableNode<T extends compiler.Node>(node: T): node is compiler.AbstractableNode & compiler.AbstractableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AmbientableNode.
     * @param node - Node to check.
     */
    static isAmbientableNode<T extends compiler.Node>(node: T): node is compiler.AmbientableNode & compiler.AmbientableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AnyKeyword.
     */
    static readonly isAnyKeyword: (node: compiler.Node) => node is compiler.Expression = TypeGuards.is(SyntaxKind.AnyKeyword);

    /**
     * Gets if the node is an ArgumentedNode.
     * @param node - Node to check.
     */
    static isArgumentedNode<T extends compiler.Node>(node: T): node is compiler.ArgumentedNode & compiler.ArgumentedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ArrayBindingPattern.
     */
    static readonly isArrayBindingPattern: (node: compiler.Node) => node is compiler.ArrayBindingPattern = TypeGuards.is(SyntaxKind.ArrayBindingPattern);
    /**
     * Gets if the node is an ArrayLiteralExpression.
     */
    static readonly isArrayLiteralExpression: (node: compiler.Node) => node is compiler.ArrayLiteralExpression = TypeGuards.is(SyntaxKind.ArrayLiteralExpression);

    /**
     * Gets if the node is an ArrayTypeNode.
     * @param node - Node to check.
     */
    static isArrayTypeNode(node: compiler.Node): node is compiler.ArrayTypeNode {
        return node.getKind() === SyntaxKind.ArrayType;
    }

    /**
     * Gets if the node is an ArrowFunction.
     */
    static readonly isArrowFunction: (node: compiler.Node) => node is compiler.ArrowFunction = TypeGuards.is(SyntaxKind.ArrowFunction);
    /**
     * Gets if the node is an AsExpression.
     */
    static readonly isAsExpression: (node: compiler.Node) => node is compiler.AsExpression = TypeGuards.is(SyntaxKind.AsExpression);

    /**
     * Gets if the node is an AsyncableNode.
     * @param node - Node to check.
     */
    static isAsyncableNode<T extends compiler.Node>(node: T): node is compiler.AsyncableNode & compiler.AsyncableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an AwaitExpression.
     */
    static readonly isAwaitExpression: (node: compiler.Node) => node is compiler.AwaitExpression = TypeGuards.is(SyntaxKind.AwaitExpression);

    /**
     * Gets if the node is an AwaitableNode.
     * @param node - Node to check.
     */
    static isAwaitableNode<T extends compiler.Node>(node: T): node is compiler.AwaitableNode & compiler.AwaitableNodeExtensionType & T {
        return node.getKind() === SyntaxKind.ForOfStatement;
    }

    /**
     * Gets if the node is a BinaryExpression.
     */
    static readonly isBinaryExpression: (node: compiler.Node) => node is compiler.BinaryExpression = TypeGuards.is(SyntaxKind.BinaryExpression);
    /**
     * Gets if the node is a BindingElement.
     */
    static readonly isBindingElement: (node: compiler.Node) => node is compiler.BindingElement = TypeGuards.is(SyntaxKind.BindingElement);

    /**
     * Gets if the node is a BindingNamedNode.
     * @param node - Node to check.
     */
    static isBindingNamedNode<T extends compiler.Node>(node: T): node is compiler.BindingNamedNode & compiler.BindingNamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.Parameter:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Block.
     */
    static readonly isBlock: (node: compiler.Node) => node is compiler.Block = TypeGuards.is(SyntaxKind.Block);

    /**
     * Gets if the node is a BodiedNode.
     * @param node - Node to check.
     */
    static isBodiedNode<T extends compiler.Node>(node: T): node is compiler.BodiedNode & compiler.BodiedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BodyableNode.
     * @param node - Node to check.
     */
    static isBodyableNode<T extends compiler.Node>(node: T): node is compiler.BodyableNode & compiler.BodyableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BooleanKeyword.
     */
    static readonly isBooleanKeyword: (node: compiler.Node) => node is compiler.Expression = TypeGuards.is(SyntaxKind.BooleanKeyword);

    /**
     * Gets if the node is a BooleanLiteral.
     * @param node - Node to check.
     */
    static isBooleanLiteral(node: compiler.Node): node is compiler.BooleanLiteral {
        switch (node.getKind()) {
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a BreakStatement.
     */
    static readonly isBreakStatement: (node: compiler.Node) => node is compiler.BreakStatement = TypeGuards.is(SyntaxKind.BreakStatement);
    /**
     * Gets if the node is a CallExpression.
     */
    static readonly isCallExpression: (node: compiler.Node) => node is compiler.CallExpression = TypeGuards.is(SyntaxKind.CallExpression);

    /**
     * Gets if the node is a CallSignatureDeclaration.
     * @param node - Node to check.
     */
    static isCallSignatureDeclaration(node: compiler.Node): node is compiler.CallSignatureDeclaration {
        return node.getKind() === SyntaxKind.CallSignature;
    }

    /**
     * Gets if the node is a CaseBlock.
     */
    static readonly isCaseBlock: (node: compiler.Node) => node is compiler.CaseBlock = TypeGuards.is(SyntaxKind.CaseBlock);
    /**
     * Gets if the node is a CaseClause.
     */
    static readonly isCaseClause: (node: compiler.Node) => node is compiler.CaseClause = TypeGuards.is(SyntaxKind.CaseClause);
    /**
     * Gets if the node is a CatchClause.
     */
    static readonly isCatchClause: (node: compiler.Node) => node is compiler.CatchClause = TypeGuards.is(SyntaxKind.CatchClause);

    /**
     * Gets if the node is a ChildOrderableNode.
     * @param node - Node to check.
     */
    static isChildOrderableNode<T extends compiler.Node>(node: T): node is compiler.ChildOrderableNode & compiler.ChildOrderableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleBlock:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.Block:
            case SyntaxKind.BreakStatement:
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.DebuggerStatement:
            case SyntaxKind.DoStatement:
            case SyntaxKind.EmptyStatement:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.IfStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.NotEmittedStatement:
            case SyntaxKind.ReturnStatement:
            case SyntaxKind.SwitchStatement:
            case SyntaxKind.ThrowStatement:
            case SyntaxKind.TryStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.WhileStatement:
            case SyntaxKind.WithStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ClassDeclaration.
     */
    static readonly isClassDeclaration: (node: compiler.Node) => node is compiler.ClassDeclaration = TypeGuards.is(SyntaxKind.ClassDeclaration);
    /**
     * Gets if the node is a ClassExpression.
     */
    static readonly isClassExpression: (node: compiler.Node) => node is compiler.ClassExpression = TypeGuards.is(SyntaxKind.ClassExpression);

    /**
     * Gets if the node is a ClassLikeDeclarationBase.
     * @param node - Node to check.
     */
    static isClassLikeDeclarationBase<T extends compiler.Node>(node: T): node is compiler.ClassLikeDeclarationBase & compiler.ClassLikeDeclarationBaseExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a CommaListExpression.
     */
    static readonly isCommaListExpression: (node: compiler.Node) => node is compiler.CommaListExpression = TypeGuards.is(SyntaxKind.CommaListExpression);
    /**
     * Gets if the node is a ComputedPropertyName.
     */
    static readonly isComputedPropertyName: (node: compiler.Node) => node is compiler.ComputedPropertyName = TypeGuards.is(SyntaxKind.ComputedPropertyName);
    /**
     * Gets if the node is a ConditionalExpression.
     */
    static readonly isConditionalExpression: (node: compiler.Node) => node is compiler.ConditionalExpression = TypeGuards.is(SyntaxKind.ConditionalExpression);

    /**
     * Gets if the node is a ConditionalTypeNode.
     * @param node - Node to check.
     */
    static isConditionalTypeNode(node: compiler.Node): node is compiler.ConditionalTypeNode {
        return node.getKind() === SyntaxKind.ConditionalType;
    }

    /**
     * Gets if the node is a ConstructSignatureDeclaration.
     * @param node - Node to check.
     */
    static isConstructSignatureDeclaration(node: compiler.Node): node is compiler.ConstructSignatureDeclaration {
        return node.getKind() === SyntaxKind.ConstructSignature;
    }

    /**
     * Gets if the node is a ConstructorDeclaration.
     * @param node - Node to check.
     */
    static isConstructorDeclaration(node: compiler.Node): node is compiler.ConstructorDeclaration {
        return node.getKind() === SyntaxKind.Constructor;
    }

    /**
     * Gets if the node is a ConstructorTypeNode.
     * @param node - Node to check.
     */
    static isConstructorTypeNode(node: compiler.Node): node is compiler.ConstructorTypeNode {
        return node.getKind() === SyntaxKind.ConstructorType;
    }

    /**
     * Gets if the node is a ContinueStatement.
     */
    static readonly isContinueStatement: (node: compiler.Node) => node is compiler.ContinueStatement = TypeGuards.is(SyntaxKind.ContinueStatement);
    /**
     * Gets if the node is a DebuggerStatement.
     */
    static readonly isDebuggerStatement: (node: compiler.Node) => node is compiler.DebuggerStatement = TypeGuards.is(SyntaxKind.DebuggerStatement);

    /**
     * Gets if the node is a DecoratableNode.
     * @param node - Node to check.
     */
    static isDecoratableNode<T extends compiler.Node>(node: T): node is compiler.DecoratableNode & compiler.DecoratableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Decorator.
     */
    static readonly isDecorator: (node: compiler.Node) => node is compiler.Decorator = TypeGuards.is(SyntaxKind.Decorator);
    /**
     * Gets if the node is a DefaultClause.
     */
    static readonly isDefaultClause: (node: compiler.Node) => node is compiler.DefaultClause = TypeGuards.is(SyntaxKind.DefaultClause);
    /**
     * Gets if the node is a DeleteExpression.
     */
    static readonly isDeleteExpression: (node: compiler.Node) => node is compiler.DeleteExpression = TypeGuards.is(SyntaxKind.DeleteExpression);
    /**
     * Gets if the node is a DoStatement.
     */
    static readonly isDoStatement: (node: compiler.Node) => node is compiler.DoStatement = TypeGuards.is(SyntaxKind.DoStatement);
    /**
     * Gets if the node is an ElementAccessExpression.
     */
    static readonly isElementAccessExpression: (node: compiler.Node) => node is compiler.ElementAccessExpression = TypeGuards.is(SyntaxKind.ElementAccessExpression);
    /**
     * Gets if the node is an EmptyStatement.
     */
    static readonly isEmptyStatement: (node: compiler.Node) => node is compiler.EmptyStatement = TypeGuards.is(SyntaxKind.EmptyStatement);
    /**
     * Gets if the node is an EnumDeclaration.
     */
    static readonly isEnumDeclaration: (node: compiler.Node) => node is compiler.EnumDeclaration = TypeGuards.is(SyntaxKind.EnumDeclaration);
    /**
     * Gets if the node is an EnumMember.
     */
    static readonly isEnumMember: (node: compiler.Node) => node is compiler.EnumMember = TypeGuards.is(SyntaxKind.EnumMember);

    /**
     * Gets if the node is an ExclamationTokenableNode.
     * @param node - Node to check.
     */
    static isExclamationTokenableNode<T extends compiler.Node>(node: T): node is compiler.ExclamationTokenableNode & compiler.ExclamationTokenableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportAssignment.
     */
    static readonly isExportAssignment: (node: compiler.Node) => node is compiler.ExportAssignment = TypeGuards.is(SyntaxKind.ExportAssignment);
    /**
     * Gets if the node is an ExportDeclaration.
     */
    static readonly isExportDeclaration: (node: compiler.Node) => node is compiler.ExportDeclaration = TypeGuards.is(SyntaxKind.ExportDeclaration);

    /**
     * Gets if the node is an ExportGetableNode.
     * @param node - Node to check.
     */
    static isExportGetableNode<T extends compiler.Node>(node: T): node is compiler.ExportGetableNode & compiler.ExportGetableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExportSpecifier.
     */
    static readonly isExportSpecifier: (node: compiler.Node) => node is compiler.ExportSpecifier = TypeGuards.is(SyntaxKind.ExportSpecifier);

    /**
     * Gets if the node is an ExportableNode.
     * @param node - Node to check.
     */
    static isExportableNode<T extends compiler.Node>(node: T): node is compiler.ExportableNode & compiler.ExportableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an Expression.
     * @param node - Node to check.
     */
    static isExpression(node: compiler.Node): node is compiler.Expression {
        switch (node.getKind()) {
            case SyntaxKind.AnyKeyword:
            case SyntaxKind.BooleanKeyword:
            case SyntaxKind.NeverKeyword:
            case SyntaxKind.NumberKeyword:
            case SyntaxKind.ObjectKeyword:
            case SyntaxKind.StringKeyword:
            case SyntaxKind.SymbolKeyword:
            case SyntaxKind.UndefinedKeyword:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.AsExpression:
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.BinaryExpression:
            case SyntaxKind.CallExpression:
            case SyntaxKind.CommaListExpression:
            case SyntaxKind.ConditionalExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.OmittedExpression:
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.PartiallyEmittedExpression:
            case SyntaxKind.PostfixUnaryExpression:
            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SpreadElement:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidExpression:
            case SyntaxKind.YieldExpression:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxClosingFragment:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxExpression:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxOpeningFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExpressionStatement.
     */
    static readonly isExpressionStatement: (node: compiler.Node) => node is compiler.ExpressionStatement = TypeGuards.is(SyntaxKind.ExpressionStatement);
    /**
     * Gets if the node is an ExpressionWithTypeArguments.
     */
    static readonly isExpressionWithTypeArguments: (node: compiler.Node) => node is compiler.ExpressionWithTypeArguments = TypeGuards.is(SyntaxKind.ExpressionWithTypeArguments);

    /**
     * Gets if the node is an ExpressionedNode.
     * @param node - Node to check.
     */
    static isExpressionedNode<T extends compiler.Node>(node: T): node is compiler.ExpressionedNode & compiler.ExpressionedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.AsExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.ParenthesizedExpression:
            case SyntaxKind.PartiallyEmittedExpression:
            case SyntaxKind.SpreadElement:
            case SyntaxKind.SpreadAssignment:
            case SyntaxKind.TemplateSpan:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is an ExtendsClauseableNode.
     * @param node - Node to check.
     */
    static isExtendsClauseableNode<T extends compiler.Node>(node: T): node is compiler.ExtendsClauseableNode & compiler.ExtendsClauseableNodeExtensionType & T {
        return node.getKind() === SyntaxKind.InterfaceDeclaration;
    }

    /**
     * Gets if the node is an ExternalModuleReference.
     */
    static readonly isExternalModuleReference: (node: compiler.Node) => node is compiler.ExternalModuleReference = TypeGuards.is(SyntaxKind.ExternalModuleReference);
    /**
     * Gets if the node is a FalseKeyword.
     */
    static readonly isFalseKeyword: (node: compiler.Node) => node is compiler.BooleanLiteral = TypeGuards.is(SyntaxKind.FalseKeyword);
    /**
     * Gets if the node is a ForInStatement.
     */
    static readonly isForInStatement: (node: compiler.Node) => node is compiler.ForInStatement = TypeGuards.is(SyntaxKind.ForInStatement);
    /**
     * Gets if the node is a ForOfStatement.
     */
    static readonly isForOfStatement: (node: compiler.Node) => node is compiler.ForOfStatement = TypeGuards.is(SyntaxKind.ForOfStatement);
    /**
     * Gets if the node is a ForStatement.
     */
    static readonly isForStatement: (node: compiler.Node) => node is compiler.ForStatement = TypeGuards.is(SyntaxKind.ForStatement);
    /**
     * Gets if the node is a FunctionDeclaration.
     */
    static readonly isFunctionDeclaration: (node: compiler.Node) => node is compiler.FunctionDeclaration = TypeGuards.is(SyntaxKind.FunctionDeclaration);
    /**
     * Gets if the node is a FunctionExpression.
     */
    static readonly isFunctionExpression: (node: compiler.Node) => node is compiler.FunctionExpression = TypeGuards.is(SyntaxKind.FunctionExpression);

    /**
     * Gets if the node is a FunctionLikeDeclaration.
     * @param node - Node to check.
     */
    static isFunctionLikeDeclaration<T extends compiler.Node>(node: T): node is compiler.FunctionLikeDeclaration & compiler.FunctionLikeDeclarationExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a FunctionTypeNode.
     * @param node - Node to check.
     */
    static isFunctionTypeNode(node: compiler.Node): node is compiler.FunctionTypeNode {
        return node.getKind() === SyntaxKind.FunctionType;
    }

    /**
     * Gets if the node is a GeneratorableNode.
     * @param node - Node to check.
     */
    static isGeneratorableNode<T extends compiler.Node>(node: T): node is compiler.GeneratorableNode & compiler.GeneratorableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.YieldExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a GetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isGetAccessorDeclaration(node: compiler.Node): node is compiler.GetAccessorDeclaration {
        return node.getKind() === SyntaxKind.GetAccessor;
    }

    /**
     * Gets if the node is a HeritageClause.
     */
    static readonly isHeritageClause: (node: compiler.Node) => node is compiler.HeritageClause = TypeGuards.is(SyntaxKind.HeritageClause);

    /**
     * Gets if the node is a HeritageClauseableNode.
     * @param node - Node to check.
     */
    static isHeritageClauseableNode<T extends compiler.Node>(node: T): node is compiler.HeritageClauseableNode & compiler.HeritageClauseableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a Identifier.
     */
    static readonly isIdentifier: (node: compiler.Node) => node is compiler.Identifier = TypeGuards.is(SyntaxKind.Identifier);
    /**
     * Gets if the node is a IfStatement.
     */
    static readonly isIfStatement: (node: compiler.Node) => node is compiler.IfStatement = TypeGuards.is(SyntaxKind.IfStatement);

    /**
     * Gets if the node is a ImplementsClauseableNode.
     * @param node - Node to check.
     */
    static isImplementsClauseableNode<T extends compiler.Node>(node: T): node is compiler.ImplementsClauseableNode & compiler.ImplementsClauseableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ImportClause.
     */
    static readonly isImportClause: (node: compiler.Node) => node is compiler.ImportClause = TypeGuards.is(SyntaxKind.ImportClause);
    /**
     * Gets if the node is a ImportDeclaration.
     */
    static readonly isImportDeclaration: (node: compiler.Node) => node is compiler.ImportDeclaration = TypeGuards.is(SyntaxKind.ImportDeclaration);
    /**
     * Gets if the node is a ImportEqualsDeclaration.
     */
    static readonly isImportEqualsDeclaration: (node: compiler.Node) => node is compiler.ImportEqualsDeclaration = TypeGuards.is(SyntaxKind.ImportEqualsDeclaration);

    /**
     * Gets if the node is a ImportExpression.
     * @param node - Node to check.
     */
    static isImportExpression(node: compiler.Node): node is compiler.ImportExpression {
        return node.getKind() === SyntaxKind.ImportKeyword;
    }

    /**
     * Gets if the node is a ImportSpecifier.
     */
    static readonly isImportSpecifier: (node: compiler.Node) => node is compiler.ImportSpecifier = TypeGuards.is(SyntaxKind.ImportSpecifier);

    /**
     * Gets if the node is a ImportTypeNode.
     * @param node - Node to check.
     */
    static isImportTypeNode(node: compiler.Node): node is compiler.ImportTypeNode {
        return node.getKind() === SyntaxKind.ImportType;
    }

    /**
     * Gets if the node is a IndexSignatureDeclaration.
     * @param node - Node to check.
     */
    static isIndexSignatureDeclaration(node: compiler.Node): node is compiler.IndexSignatureDeclaration {
        return node.getKind() === SyntaxKind.IndexSignature;
    }

    /**
     * Gets if the node is a IndexedAccessTypeNode.
     * @param node - Node to check.
     */
    static isIndexedAccessTypeNode(node: compiler.Node): node is compiler.IndexedAccessTypeNode {
        return node.getKind() === SyntaxKind.IndexedAccessType;
    }

    /**
     * Gets if the node is a InferKeyword.
     */
    static isInferKeyword(node: compiler.Node): node is compiler.Node<Token<SyntaxKind.InferKeyword>> { 
        return node.getKind() === SyntaxKind.InferKeyword;
    }

    /**
     * Gets if the node is a InferTypeNode.
     * @param node - Node to check.
     */
    static isInferTypeNode(node: compiler.Node): node is compiler.InferTypeNode {
        return node.getKind() === SyntaxKind.InferType;
    }

    /**
     * Gets if the node is a InitializerExpressionGetableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionGetableNode<T extends compiler.Node>(node: T): node is compiler.InitializerExpressionGetableNode & compiler.InitializerExpressionGetableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InitializerExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionableNode<T extends compiler.Node>(node: T): node is compiler.InitializerExpressionableNode & compiler.InitializerExpressionableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a InterfaceDeclaration.
     */
    static readonly isInterfaceDeclaration: (node: compiler.Node) => node is compiler.InterfaceDeclaration = TypeGuards.is(SyntaxKind.InterfaceDeclaration);

    /**
     * Gets if the node is a IntersectionTypeNode.
     * @param node - Node to check.
     */
    static isIntersectionTypeNode(node: compiler.Node): node is compiler.IntersectionTypeNode {
        return node.getKind() === SyntaxKind.IntersectionType;
    }

    /**
     * Gets if the node is a IterationStatement.
     * @param node - Node to check.
     */
    static isIterationStatement(node: compiler.Node): node is compiler.IterationStatement {
        switch (node.getKind()) {
            case SyntaxKind.DoStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.WhileStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDoc.
     * @param node - Node to check.
     */
    static isJSDoc(node: compiler.Node): node is compiler.JSDoc {
        return node.getKind() === SyntaxKind.JSDocComment;
    }

    /**
     * Gets if the node is a JSDocAugmentsTag.
     */
    static readonly isJSDocAugmentsTag: (node: compiler.Node) => node is compiler.JSDocAugmentsTag = TypeGuards.is(SyntaxKind.JSDocAugmentsTag);
    /**
     * Gets if the node is a JSDocClassTag.
     */
    static readonly isJSDocClassTag: (node: compiler.Node) => node is compiler.JSDocClassTag = TypeGuards.is(SyntaxKind.JSDocClassTag);
    /**
     * Gets if the node is a JSDocFunctionType.
     */
    static readonly isJSDocFunctionType: (node: compiler.Node) => node is compiler.JSDocFunctionType = TypeGuards.is(SyntaxKind.JSDocFunctionType);
    /**
     * Gets if the node is a JSDocParameterTag.
     */
    static readonly isJSDocParameterTag: (node: compiler.Node) => node is compiler.JSDocParameterTag = TypeGuards.is(SyntaxKind.JSDocParameterTag);

    /**
     * Gets if the node is a JSDocPropertyLikeTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyLikeTag<T extends compiler.Node>(node: T): node is compiler.JSDocPropertyLikeTag & compiler.JSDocPropertyLikeTagExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JSDocParameterTag:
            case SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocPropertyTag.
     */
    static readonly isJSDocPropertyTag: (node: compiler.Node) => node is compiler.JSDocPropertyTag = TypeGuards.is(SyntaxKind.JSDocPropertyTag);
    /**
     * Gets if the node is a JSDocReturnTag.
     */
    static readonly isJSDocReturnTag: (node: compiler.Node) => node is compiler.JSDocReturnTag = TypeGuards.is(SyntaxKind.JSDocReturnTag);
    /**
     * Gets if the node is a JSDocSignature.
     */
    static readonly isJSDocSignature: (node: compiler.Node) => node is compiler.JSDocSignature = TypeGuards.is(SyntaxKind.JSDocSignature);

    /**
     * Gets if the node is a JSDocTag.
     * @param node - Node to check.
     */
    static isJSDocTag(node: compiler.Node): node is compiler.JSDocTag {
        switch (node.getKind()) {
            case SyntaxKind.JSDocAugmentsTag:
            case SyntaxKind.JSDocClassTag:
            case SyntaxKind.JSDocParameterTag:
            case SyntaxKind.JSDocPropertyTag:
            case SyntaxKind.JSDocReturnTag:
            case SyntaxKind.JSDocTypedefTag:
            case SyntaxKind.JSDocTypeTag:
            case SyntaxKind.JSDocTag:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocType.
     * @param node - Node to check.
     */
    static isJSDocType(node: compiler.Node): node is compiler.JSDocType {
        switch (node.getKind()) {
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.JSDocSignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JSDocTypeExpression.
     */
    static readonly isJSDocTypeExpression: (node: compiler.Node) => node is compiler.JSDocTypeExpression = TypeGuards.is(SyntaxKind.JSDocTypeExpression);
    /**
     * Gets if the node is a JSDocTypeTag.
     */
    static readonly isJSDocTypeTag: (node: compiler.Node) => node is compiler.JSDocTypeTag = TypeGuards.is(SyntaxKind.JSDocTypeTag);
    /**
     * Gets if the node is a JSDocTypedefTag.
     */
    static readonly isJSDocTypedefTag: (node: compiler.Node) => node is compiler.JSDocTypedefTag = TypeGuards.is(SyntaxKind.JSDocTypedefTag);

    /**
     * Gets if the node is a JSDocUnknownTag.
     * @param node - Node to check.
     */
    static isJSDocUnknownTag(node: compiler.Node): node is compiler.JSDocUnknownTag {
        return node.getKind() === SyntaxKind.JSDocTag;
    }

    /**
     * Gets if the node is a JSDocableNode.
     * @param node - Node to check.
     */
    static isJSDocableNode<T extends compiler.Node>(node: T): node is compiler.JSDocableNode & compiler.JSDocableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxAttribute.
     */
    static readonly isJsxAttribute: (node: compiler.Node) => node is compiler.JsxAttribute = TypeGuards.is(SyntaxKind.JsxAttribute);

    /**
     * Gets if the node is a JsxAttributedNode.
     * @param node - Node to check.
     */
    static isJsxAttributedNode<T extends compiler.Node>(node: T): node is compiler.JsxAttributedNode & compiler.JsxAttributedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxClosingElement.
     */
    static readonly isJsxClosingElement: (node: compiler.Node) => node is compiler.JsxClosingElement = TypeGuards.is(SyntaxKind.JsxClosingElement);
    /**
     * Gets if the node is a JsxClosingFragment.
     */
    static readonly isJsxClosingFragment: (node: compiler.Node) => node is compiler.JsxClosingFragment = TypeGuards.is(SyntaxKind.JsxClosingFragment);
    /**
     * Gets if the node is a JsxElement.
     */
    static readonly isJsxElement: (node: compiler.Node) => node is compiler.JsxElement = TypeGuards.is(SyntaxKind.JsxElement);
    /**
     * Gets if the node is a JsxExpression.
     */
    static readonly isJsxExpression: (node: compiler.Node) => node is compiler.JsxExpression = TypeGuards.is(SyntaxKind.JsxExpression);
    /**
     * Gets if the node is a JsxFragment.
     */
    static readonly isJsxFragment: (node: compiler.Node) => node is compiler.JsxFragment = TypeGuards.is(SyntaxKind.JsxFragment);
    /**
     * Gets if the node is a JsxOpeningElement.
     */
    static readonly isJsxOpeningElement: (node: compiler.Node) => node is compiler.JsxOpeningElement = TypeGuards.is(SyntaxKind.JsxOpeningElement);
    /**
     * Gets if the node is a JsxOpeningFragment.
     */
    static readonly isJsxOpeningFragment: (node: compiler.Node) => node is compiler.JsxOpeningFragment = TypeGuards.is(SyntaxKind.JsxOpeningFragment);
    /**
     * Gets if the node is a JsxSelfClosingElement.
     */
    static readonly isJsxSelfClosingElement: (node: compiler.Node) => node is compiler.JsxSelfClosingElement = TypeGuards.is(SyntaxKind.JsxSelfClosingElement);
    /**
     * Gets if the node is a JsxSpreadAttribute.
     */
    static readonly isJsxSpreadAttribute: (node: compiler.Node) => node is compiler.JsxSpreadAttribute = TypeGuards.is(SyntaxKind.JsxSpreadAttribute);

    /**
     * Gets if the node is a JsxTagNamedNode.
     * @param node - Node to check.
     */
    static isJsxTagNamedNode<T extends compiler.Node>(node: T): node is compiler.JsxTagNamedNode & compiler.JsxTagNamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JsxClosingElement:
            case SyntaxKind.JsxOpeningElement:
            case SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a JsxText.
     */
    static readonly isJsxText: (node: compiler.Node) => node is compiler.JsxText = TypeGuards.is(SyntaxKind.JsxText);
    /**
     * Gets if the node is a LabeledStatement.
     */
    static readonly isLabeledStatement: (node: compiler.Node) => node is compiler.LabeledStatement = TypeGuards.is(SyntaxKind.LabeledStatement);

    /**
     * Gets if the node is a LeftHandSideExpression.
     * @param node - Node to check.
     */
    static isLeftHandSideExpression(node: compiler.Node): node is compiler.LeftHandSideExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LeftHandSideExpressionedNode.
     * @param node - Node to check.
     */
    static isLeftHandSideExpressionedNode<T extends compiler.Node>(node: T): node is compiler.LeftHandSideExpressionedNode & compiler.LeftHandSideExpressionedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.NewExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ExpressionWithTypeArguments:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralExpression.
     * @param node - Node to check.
     */
    static isLiteralExpression(node: compiler.Node): node is compiler.LiteralExpression {
        switch (node.getKind()) {
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralLikeNode.
     * @param node - Node to check.
     */
    static isLiteralLikeNode<T extends compiler.Node>(node: T): node is compiler.LiteralLikeNode & compiler.LiteralLikeNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.JsxText:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TemplateHead:
            case SyntaxKind.TemplateMiddle:
            case SyntaxKind.TemplateTail:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a LiteralTypeNode.
     * @param node - Node to check.
     */
    static isLiteralTypeNode(node: compiler.Node): node is compiler.LiteralTypeNode {
        return node.getKind() === SyntaxKind.LiteralType;
    }

    /**
     * Gets if the node is a MemberExpression.
     * @param node - Node to check.
     */
    static isMemberExpression(node: compiler.Node): node is compiler.MemberExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a MetaProperty.
     */
    static readonly isMetaProperty: (node: compiler.Node) => node is compiler.MetaProperty = TypeGuards.is(SyntaxKind.MetaProperty);
    /**
     * Gets if the node is a MethodDeclaration.
     */
    static readonly isMethodDeclaration: (node: compiler.Node) => node is compiler.MethodDeclaration = TypeGuards.is(SyntaxKind.MethodDeclaration);
    /**
     * Gets if the node is a MethodSignature.
     */
    static readonly isMethodSignature: (node: compiler.Node) => node is compiler.MethodSignature = TypeGuards.is(SyntaxKind.MethodSignature);

    /**
     * Gets if the node is a ModifierableNode.
     * @param node - Node to check.
     */
    static isModifierableNode<T extends compiler.Node>(node: T): node is compiler.ModifierableNode & compiler.ModifierableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.VariableDeclarationList:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ModuleBlock.
     */
    static readonly isModuleBlock: (node: compiler.Node) => node is compiler.ModuleBlock = TypeGuards.is(SyntaxKind.ModuleBlock);

    /**
     * Gets if the node is a ModuledNode.
     * @param node - Node to check.
     */
    static isModuledNode<T extends compiler.Node>(node: T): node is compiler.ModuledNode & compiler.ModuledNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NameableNode.
     * @param node - Node to check.
     */
    static isNameableNode<T extends compiler.Node>(node: T): node is compiler.NameableNode & compiler.NameableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamedExports.
     */
    static readonly isNamedExports: (node: compiler.Node) => node is compiler.NamedExports = TypeGuards.is(SyntaxKind.NamedExports);
    /**
     * Gets if the node is a NamedImports.
     */
    static readonly isNamedImports: (node: compiler.Node) => node is compiler.NamedImports = TypeGuards.is(SyntaxKind.NamedImports);

    /**
     * Gets if the node is a NamedNode.
     * @param node - Node to check.
     */
    static isNamedNode<T extends compiler.Node>(node: T): node is compiler.NamedNode & compiler.NamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamespaceChildableNode.
     * @param node - Node to check.
     */
    static isNamespaceChildableNode<T extends compiler.Node>(node: T): node is compiler.NamespaceChildableNode & compiler.NamespaceChildableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a NamespaceDeclaration.
     * @param node - Node to check.
     */
    static isNamespaceDeclaration(node: compiler.Node): node is compiler.NamespaceDeclaration {
        return node.getKind() === SyntaxKind.ModuleDeclaration;
    }

    /**
     * Gets if the node is a NamespaceImport.
     */
    static readonly isNamespaceImport: (node: compiler.Node) => node is compiler.NamespaceImport = TypeGuards.is(SyntaxKind.NamespaceImport);
    /**
     * Gets if the node is a NeverKeyword.
     */
    static readonly isNeverKeyword: (node: compiler.Node) => node is compiler.Expression = TypeGuards.is(SyntaxKind.NeverKeyword);
    /**
     * Gets if the node is a NewExpression.
     */
    static readonly isNewExpression: (node: compiler.Node) => node is compiler.NewExpression = TypeGuards.is(SyntaxKind.NewExpression);
    /**
     * Gets if the node is a NoSubstitutionTemplateLiteral.
     */
    static readonly isNoSubstitutionTemplateLiteral: (node: compiler.Node) => node is compiler.NoSubstitutionTemplateLiteral = TypeGuards.is(SyntaxKind.NoSubstitutionTemplateLiteral);
    /**
     * Gets if the node is a NonNullExpression.
     */
    static readonly isNonNullExpression: (node: compiler.Node) => node is compiler.NonNullExpression = TypeGuards.is(SyntaxKind.NonNullExpression);
    /**
     * Gets if the node is a NotEmittedStatement.
     */
    static readonly isNotEmittedStatement: (node: compiler.Node) => node is compiler.NotEmittedStatement = TypeGuards.is(SyntaxKind.NotEmittedStatement);

    /**
     * Gets if the node is a NullLiteral.
     * @param node - Node to check.
     */
    static isNullLiteral(node: compiler.Node): node is compiler.NullLiteral {
        return node.getKind() === SyntaxKind.NullKeyword;
    }

    /**
     * Gets if the node is a NumberKeyword.
     */
    static readonly isNumberKeyword: (node: compiler.Node) => node is compiler.Expression = TypeGuards.is(SyntaxKind.NumberKeyword);
    /**
     * Gets if the node is a NumericLiteral.
     */
    static readonly isNumericLiteral: (node: compiler.Node) => node is compiler.NumericLiteral = TypeGuards.is(SyntaxKind.NumericLiteral);
    /**
     * Gets if the node is a ObjectBindingPattern.
     */
    static readonly isObjectBindingPattern: (node: compiler.Node) => node is compiler.ObjectBindingPattern = TypeGuards.is(SyntaxKind.ObjectBindingPattern);
    /**
     * Gets if the node is a ObjectKeyword.
     */
    static readonly isObjectKeyword: (node: compiler.Node) => node is compiler.Expression = TypeGuards.is(SyntaxKind.ObjectKeyword);
    /**
     * Gets if the node is a ObjectLiteralExpression.
     */
    static readonly isObjectLiteralExpression: (node: compiler.Node) => node is compiler.ObjectLiteralExpression = TypeGuards.is(SyntaxKind.ObjectLiteralExpression);
    /**
     * Gets if the node is a OmittedExpression.
     */
    static readonly isOmittedExpression: (node: compiler.Node) => node is compiler.OmittedExpression = TypeGuards.is(SyntaxKind.OmittedExpression);

    /**
     * Gets if the node is a OverloadableNode.
     * @param node - Node to check.
     */
    static isOverloadableNode<T extends compiler.Node>(node: T): node is compiler.OverloadableNode & compiler.OverloadableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ParameterDeclaration.
     * @param node - Node to check.
     */
    static isParameterDeclaration(node: compiler.Node): node is compiler.ParameterDeclaration {
        return node.getKind() === SyntaxKind.Parameter;
    }

    /**
     * Gets if the node is a ParameteredNode.
     * @param node - Node to check.
     */
    static isParameteredNode<T extends compiler.Node>(node: T): node is compiler.ParameteredNode & compiler.ParameteredNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ParenthesizedExpression.
     */
    static readonly isParenthesizedExpression: (node: compiler.Node) => node is compiler.ParenthesizedExpression = TypeGuards.is(SyntaxKind.ParenthesizedExpression);

    /**
     * Gets if the node is a ParenthesizedTypeNode.
     * @param node - Node to check.
     */
    static isParenthesizedTypeNode(node: compiler.Node): node is compiler.ParenthesizedTypeNode {
        return node.getKind() === SyntaxKind.ParenthesizedType;
    }

    /**
     * Gets if the node is a PartiallyEmittedExpression.
     */
    static readonly isPartiallyEmittedExpression: (node: compiler.Node) => node is compiler.PartiallyEmittedExpression = TypeGuards.is(SyntaxKind.PartiallyEmittedExpression);
    /**
     * Gets if the node is a PostfixUnaryExpression.
     */
    static readonly isPostfixUnaryExpression: (node: compiler.Node) => node is compiler.PostfixUnaryExpression = TypeGuards.is(SyntaxKind.PostfixUnaryExpression);
    /**
     * Gets if the node is a PrefixUnaryExpression.
     */
    static readonly isPrefixUnaryExpression: (node: compiler.Node) => node is compiler.PrefixUnaryExpression = TypeGuards.is(SyntaxKind.PrefixUnaryExpression);

    /**
     * Gets if the node is a PrimaryExpression.
     * @param node - Node to check.
     */
    static isPrimaryExpression(node: compiler.Node): node is compiler.PrimaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertyAccessExpression.
     */
    static readonly isPropertyAccessExpression: (node: compiler.Node) => node is compiler.PropertyAccessExpression = TypeGuards.is(SyntaxKind.PropertyAccessExpression);
    /**
     * Gets if the node is a PropertyAssignment.
     */
    static readonly isPropertyAssignment: (node: compiler.Node) => node is compiler.PropertyAssignment = TypeGuards.is(SyntaxKind.PropertyAssignment);
    /**
     * Gets if the node is a PropertyDeclaration.
     */
    static readonly isPropertyDeclaration: (node: compiler.Node) => node is compiler.PropertyDeclaration = TypeGuards.is(SyntaxKind.PropertyDeclaration);

    /**
     * Gets if the node is a PropertyNamedNode.
     * @param node - Node to check.
     */
    static isPropertyNamedNode<T extends compiler.Node>(node: T): node is compiler.PropertyNamedNode & compiler.PropertyNamedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a PropertySignature.
     */
    static readonly isPropertySignature: (node: compiler.Node) => node is compiler.PropertySignature = TypeGuards.is(SyntaxKind.PropertySignature);
    /**
     * Gets if the node is a QualifiedName.
     */
    static readonly isQualifiedName: (node: compiler.Node) => node is compiler.QualifiedName = TypeGuards.is(SyntaxKind.QualifiedName);

    /**
     * Gets if the node is a QuestionTokenableNode.
     * @param node - Node to check.
     */
    static isQuestionTokenableNode<T extends compiler.Node>(node: T): node is compiler.QuestionTokenableNode & compiler.QuestionTokenableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReadonlyableNode.
     * @param node - Node to check.
     */
    static isReadonlyableNode<T extends compiler.Node>(node: T): node is compiler.ReadonlyableNode & compiler.ReadonlyableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReferenceFindableNode.
     * @param node - Node to check.
     */
    static isReferenceFindableNode<T extends compiler.Node>(node: T): node is compiler.ReferenceFindableNode & compiler.ReferenceFindableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Identifier:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a RegularExpressionLiteral.
     */
    static readonly isRegularExpressionLiteral: (node: compiler.Node) => node is compiler.RegularExpressionLiteral = TypeGuards.is(SyntaxKind.RegularExpressionLiteral);

    /**
     * Gets if the node is a RenameableNode.
     * @param node - Node to check.
     */
    static isRenameableNode<T extends compiler.Node>(node: T): node is compiler.RenameableNode & compiler.RenameableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.BindingElement:
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Identifier:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.NamespaceImport:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ReturnStatement.
     */
    static readonly isReturnStatement: (node: compiler.Node) => node is compiler.ReturnStatement = TypeGuards.is(SyntaxKind.ReturnStatement);

    /**
     * Gets if the node is a ReturnTypedNode.
     * @param node - Node to check.
     */
    static isReturnTypedNode<T extends compiler.Node>(node: T): node is compiler.ReturnTypedNode & compiler.ReturnTypedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ScopeableNode.
     * @param node - Node to check.
     */
    static isScopeableNode<T extends compiler.Node>(node: T): node is compiler.ScopeableNode & compiler.ScopeableNodeExtensionType & T {
        return node.getKind() === SyntaxKind.Parameter;
    }

    /**
     * Gets if the node is a ScopedNode.
     * @param node - Node to check.
     */
    static isScopedNode<T extends compiler.Node>(node: T): node is compiler.ScopedNode & compiler.ScopedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SemicolonToken.
     */
    static isSemicolonToken(node: compiler.Node): node is compiler.Node<Token<SyntaxKind.SemicolonToken>> { 
        return node.getKind() === SyntaxKind.SemicolonToken;
    }

    /**
     * Gets if the node is a SetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isSetAccessorDeclaration(node: compiler.Node): node is compiler.SetAccessorDeclaration {
        return node.getKind() === SyntaxKind.SetAccessor;
    }

    /**
     * Gets if the node is a ShorthandPropertyAssignment.
     */
    static readonly isShorthandPropertyAssignment: (node: compiler.Node) => node is compiler.ShorthandPropertyAssignment = TypeGuards.is(SyntaxKind.ShorthandPropertyAssignment);

    /**
     * Gets if the node is a SignaturedDeclaration.
     * @param node - Node to check.
     */
    static isSignaturedDeclaration<T extends compiler.Node>(node: T): node is compiler.SignaturedDeclaration & compiler.SignaturedDeclarationExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a SourceFile.
     */
    static readonly isSourceFile: (node: compiler.Node) => node is compiler.SourceFile = TypeGuards.is(SyntaxKind.SourceFile);
    /**
     * Gets if the node is a SpreadAssignment.
     */
    static readonly isSpreadAssignment: (node: compiler.Node) => node is compiler.SpreadAssignment = TypeGuards.is(SyntaxKind.SpreadAssignment);
    /**
     * Gets if the node is a SpreadElement.
     */
    static readonly isSpreadElement: (node: compiler.Node) => node is compiler.SpreadElement = TypeGuards.is(SyntaxKind.SpreadElement);

    /**
     * Gets if the node is a Statement.
     * @param node - Node to check.
     */
    static isStatement(node: compiler.Node): node is compiler.Statement {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportEqualsDeclaration:
            case SyntaxKind.ModuleBlock:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.Block:
            case SyntaxKind.BreakStatement:
            case SyntaxKind.ContinueStatement:
            case SyntaxKind.DebuggerStatement:
            case SyntaxKind.DoStatement:
            case SyntaxKind.EmptyStatement:
            case SyntaxKind.ExpressionStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.IfStatement:
            case SyntaxKind.LabeledStatement:
            case SyntaxKind.NotEmittedStatement:
            case SyntaxKind.ReturnStatement:
            case SyntaxKind.SwitchStatement:
            case SyntaxKind.ThrowStatement:
            case SyntaxKind.TryStatement:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.WhileStatement:
            case SyntaxKind.WithStatement:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StatementedNode.
     * @param node - Node to check.
     */
    static isStatementedNode<T extends compiler.Node>(node: T): node is compiler.StatementedNode & compiler.StatementedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.ModuleBlock:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.Block:
            case SyntaxKind.CaseClause:
            case SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StaticableNode.
     * @param node - Node to check.
     */
    static isStaticableNode<T extends compiler.Node>(node: T): node is compiler.StaticableNode & compiler.StaticableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a StringKeyword.
     */
    static readonly isStringKeyword: (node: compiler.Node) => node is compiler.Expression = TypeGuards.is(SyntaxKind.StringKeyword);
    /**
     * Gets if the node is a StringLiteral.
     */
    static readonly isStringLiteral: (node: compiler.Node) => node is compiler.StringLiteral = TypeGuards.is(SyntaxKind.StringLiteral);

    /**
     * Gets if the node is a SuperExpression.
     * @param node - Node to check.
     */
    static isSuperExpression(node: compiler.Node): node is compiler.SuperExpression {
        return node.getKind() === SyntaxKind.SuperKeyword;
    }

    /**
     * Gets if the node is a SwitchStatement.
     */
    static readonly isSwitchStatement: (node: compiler.Node) => node is compiler.SwitchStatement = TypeGuards.is(SyntaxKind.SwitchStatement);
    /**
     * Gets if the node is a SymbolKeyword.
     */
    static readonly isSymbolKeyword: (node: compiler.Node) => node is compiler.Expression = TypeGuards.is(SyntaxKind.SymbolKeyword);
    /**
     * Gets if the node is a SyntaxList.
     */
    static readonly isSyntaxList: (node: compiler.Node) => node is compiler.SyntaxList = TypeGuards.is(SyntaxKind.SyntaxList);
    /**
     * Gets if the node is a TaggedTemplateExpression.
     */
    static readonly isTaggedTemplateExpression: (node: compiler.Node) => node is compiler.TaggedTemplateExpression = TypeGuards.is(SyntaxKind.TaggedTemplateExpression);
    /**
     * Gets if the node is a TemplateExpression.
     */
    static readonly isTemplateExpression: (node: compiler.Node) => node is compiler.TemplateExpression = TypeGuards.is(SyntaxKind.TemplateExpression);
    /**
     * Gets if the node is a TemplateHead.
     */
    static readonly isTemplateHead: (node: compiler.Node) => node is compiler.TemplateHead = TypeGuards.is(SyntaxKind.TemplateHead);
    /**
     * Gets if the node is a TemplateMiddle.
     */
    static readonly isTemplateMiddle: (node: compiler.Node) => node is compiler.TemplateMiddle = TypeGuards.is(SyntaxKind.TemplateMiddle);
    /**
     * Gets if the node is a TemplateSpan.
     */
    static readonly isTemplateSpan: (node: compiler.Node) => node is compiler.TemplateSpan = TypeGuards.is(SyntaxKind.TemplateSpan);
    /**
     * Gets if the node is a TemplateTail.
     */
    static readonly isTemplateTail: (node: compiler.Node) => node is compiler.TemplateTail = TypeGuards.is(SyntaxKind.TemplateTail);

    /**
     * Gets if the node is a TextInsertableNode.
     * @param node - Node to check.
     */
    static isTextInsertableNode<T extends compiler.Node>(node: T): node is compiler.TextInsertableNode & compiler.TextInsertableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.Block:
            case SyntaxKind.CaseBlock:
            case SyntaxKind.CaseClause:
            case SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a ThisExpression.
     * @param node - Node to check.
     */
    static isThisExpression(node: compiler.Node): node is compiler.ThisExpression {
        return node.getKind() === SyntaxKind.ThisKeyword;
    }

    /**
     * Gets if the node is a ThisTypeNode.
     * @param node - Node to check.
     */
    static isThisTypeNode(node: compiler.Node): node is compiler.ThisTypeNode {
        return node.getKind() === SyntaxKind.ThisType;
    }

    /**
     * Gets if the node is a ThrowStatement.
     */
    static readonly isThrowStatement: (node: compiler.Node) => node is compiler.ThrowStatement = TypeGuards.is(SyntaxKind.ThrowStatement);
    /**
     * Gets if the node is a TrueKeyword.
     */
    static readonly isTrueKeyword: (node: compiler.Node) => node is compiler.BooleanLiteral = TypeGuards.is(SyntaxKind.TrueKeyword);
    /**
     * Gets if the node is a TryStatement.
     */
    static readonly isTryStatement: (node: compiler.Node) => node is compiler.TryStatement = TypeGuards.is(SyntaxKind.TryStatement);

    /**
     * Gets if the node is a TupleTypeNode.
     * @param node - Node to check.
     */
    static isTupleTypeNode(node: compiler.Node): node is compiler.TupleTypeNode {
        return node.getKind() === SyntaxKind.TupleType;
    }

    /**
     * Gets if the node is a TypeAliasDeclaration.
     */
    static readonly isTypeAliasDeclaration: (node: compiler.Node) => node is compiler.TypeAliasDeclaration = TypeGuards.is(SyntaxKind.TypeAliasDeclaration);

    /**
     * Gets if the node is a TypeArgumentedNode.
     * @param node - Node to check.
     */
    static isTypeArgumentedNode<T extends compiler.Node>(node: T): node is compiler.TypeArgumentedNode & compiler.TypeArgumentedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.CallExpression:
            case SyntaxKind.NewExpression:
            case SyntaxKind.ImportType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeAssertion.
     * @param node - Node to check.
     */
    static isTypeAssertion(node: compiler.Node): node is compiler.TypeAssertion {
        return node.getKind() === SyntaxKind.TypeAssertionExpression;
    }

    /**
     * Gets if the node is a TypeElement.
     * @param node - Node to check.
     */
    static isTypeElement(node: compiler.Node): node is compiler.TypeElement {
        switch (node.getKind()) {
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeElementMemberedNode.
     * @param node - Node to check.
     */
    static isTypeElementMemberedNode<T extends compiler.Node>(node: T): node is compiler.TypeElementMemberedNode & compiler.TypeElementMemberedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.TypeLiteral:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeLiteralNode.
     * @param node - Node to check.
     */
    static isTypeLiteralNode(node: compiler.Node): node is compiler.TypeLiteralNode {
        return node.getKind() === SyntaxKind.TypeLiteral;
    }

    /**
     * Gets if the node is a TypeNode.
     * @param node - Node to check.
     */
    static isTypeNode(node: compiler.Node): node is compiler.TypeNode {
        switch (node.getKind()) {
            case SyntaxKind.JSDocFunctionType:
            case SyntaxKind.JSDocSignature:
            case SyntaxKind.JSDocTypeExpression:
            case SyntaxKind.ArrayType:
            case SyntaxKind.ConditionalType:
            case SyntaxKind.ConstructorType:
            case SyntaxKind.ExpressionWithTypeArguments:
            case SyntaxKind.FunctionType:
            case SyntaxKind.ImportType:
            case SyntaxKind.IndexedAccessType:
            case SyntaxKind.InferType:
            case SyntaxKind.IntersectionType:
            case SyntaxKind.LiteralType:
            case SyntaxKind.ParenthesizedType:
            case SyntaxKind.ThisType:
            case SyntaxKind.TupleType:
            case SyntaxKind.TypeLiteral:
            case SyntaxKind.TypePredicate:
            case SyntaxKind.TypeReference:
            case SyntaxKind.UnionType:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypeOfExpression.
     */
    static readonly isTypeOfExpression: (node: compiler.Node) => node is compiler.TypeOfExpression = TypeGuards.is(SyntaxKind.TypeOfExpression);

    /**
     * Gets if the node is a TypeParameterDeclaration.
     * @param node - Node to check.
     */
    static isTypeParameterDeclaration(node: compiler.Node): node is compiler.TypeParameterDeclaration {
        return node.getKind() === SyntaxKind.TypeParameter;
    }

    /**
     * Gets if the node is a TypeParameteredNode.
     * @param node - Node to check.
     */
    static isTypeParameteredNode<T extends compiler.Node>(node: T): node is compiler.TypeParameteredNode & compiler.TypeParameteredNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.ArrowFunction:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.FunctionType:
            case SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a TypePredicateNode.
     * @param node - Node to check.
     */
    static isTypePredicateNode(node: compiler.Node): node is compiler.TypePredicateNode {
        return node.getKind() === SyntaxKind.TypePredicate;
    }

    /**
     * Gets if the node is a TypeReferenceNode.
     * @param node - Node to check.
     */
    static isTypeReferenceNode(node: compiler.Node): node is compiler.TypeReferenceNode {
        return node.getKind() === SyntaxKind.TypeReference;
    }

    /**
     * Gets if the node is a TypedNode.
     * @param node - Node to check.
     */
    static isTypedNode<T extends compiler.Node>(node: T): node is compiler.TypedNode & compiler.TypedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.AsExpression:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnaryExpression.
     * @param node - Node to check.
     */
    static isUnaryExpression(node: compiler.Node): node is compiler.UnaryExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.CallExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PostfixUnaryExpression:
            case SyntaxKind.PrefixUnaryExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidExpression:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UnaryExpressionedNode.
     * @param node - Node to check.
     */
    static isUnaryExpressionedNode<T extends compiler.Node>(node: T): node is compiler.UnaryExpressionedNode & compiler.UnaryExpressionedNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.AwaitExpression:
            case SyntaxKind.DeleteExpression:
            case SyntaxKind.TypeAssertionExpression:
            case SyntaxKind.TypeOfExpression:
            case SyntaxKind.VoidExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UndefinedKeyword.
     */
    static readonly isUndefinedKeyword: (node: compiler.Node) => node is compiler.Expression = TypeGuards.is(SyntaxKind.UndefinedKeyword);

    /**
     * Gets if the node is a UnionTypeNode.
     * @param node - Node to check.
     */
    static isUnionTypeNode(node: compiler.Node): node is compiler.UnionTypeNode {
        return node.getKind() === SyntaxKind.UnionType;
    }

    /**
     * Gets if the node is a UnwrappableNode.
     * @param node - Node to check.
     */
    static isUnwrappableNode<T extends compiler.Node>(node: T): node is compiler.UnwrappableNode & compiler.UnwrappableNodeExtensionType & T {
        switch (node.getKind()) {
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a UpdateExpression.
     * @param node - Node to check.
     */
    static isUpdateExpression(node: compiler.Node): node is compiler.UpdateExpression {
        switch (node.getKind()) {
            case SyntaxKind.ClassExpression:
            case SyntaxKind.Identifier:
            case SyntaxKind.CallExpression:
            case SyntaxKind.ElementAccessExpression:
            case SyntaxKind.ImportKeyword:
            case SyntaxKind.MetaProperty:
            case SyntaxKind.NewExpression:
            case SyntaxKind.NonNullExpression:
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.SuperKeyword:
            case SyntaxKind.ThisKeyword:
            case SyntaxKind.FunctionExpression:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxFragment:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.FalseKeyword:
            case SyntaxKind.TrueKeyword:
            case SyntaxKind.NullKeyword:
            case SyntaxKind.NumericLiteral:
            case SyntaxKind.RegularExpressionLiteral:
            case SyntaxKind.StringLiteral:
            case SyntaxKind.ArrayLiteralExpression:
            case SyntaxKind.ObjectLiteralExpression:
            case SyntaxKind.NoSubstitutionTemplateLiteral:
            case SyntaxKind.TaggedTemplateExpression:
            case SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }

    /**
     * Gets if the node is a VariableDeclaration.
     */
    static readonly isVariableDeclaration: (node: compiler.Node) => node is compiler.VariableDeclaration = TypeGuards.is(SyntaxKind.VariableDeclaration);
    /**
     * Gets if the node is a VariableDeclarationList.
     */
    static readonly isVariableDeclarationList: (node: compiler.Node) => node is compiler.VariableDeclarationList = TypeGuards.is(SyntaxKind.VariableDeclarationList);
    /**
     * Gets if the node is a VariableStatement.
     */
    static readonly isVariableStatement: (node: compiler.Node) => node is compiler.VariableStatement = TypeGuards.is(SyntaxKind.VariableStatement);
    /**
     * Gets if the node is a VoidExpression.
     */
    static readonly isVoidExpression: (node: compiler.Node) => node is compiler.VoidExpression = TypeGuards.is(SyntaxKind.VoidExpression);
    /**
     * Gets if the node is a WhileStatement.
     */
    static readonly isWhileStatement: (node: compiler.Node) => node is compiler.WhileStatement = TypeGuards.is(SyntaxKind.WhileStatement);
    /**
     * Gets if the node is a WithStatement.
     */
    static readonly isWithStatement: (node: compiler.Node) => node is compiler.WithStatement = TypeGuards.is(SyntaxKind.WithStatement);
    /**
     * Gets if the node is a YieldExpression.
     */
    static readonly isYieldExpression: (node: compiler.Node) => node is compiler.YieldExpression = TypeGuards.is(SyntaxKind.YieldExpression);

    /**
     * @internal
     */
    static _hasStructure(node: compiler.Node): node is compiler.Node & { getStructure(): Structure; } {
        switch (node.getKind()) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.Constructor:
            case SyntaxKind.GetAccessor:
            case SyntaxKind.MethodDeclaration:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.SetAccessor:
            case SyntaxKind.Decorator:
            case SyntaxKind.JSDocComment:
            case SyntaxKind.EnumDeclaration:
            case SyntaxKind.EnumMember:
            case SyntaxKind.FunctionDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.CallSignature:
            case SyntaxKind.ConstructSignature:
            case SyntaxKind.IndexSignature:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.MethodSignature:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.JsxAttribute:
            case SyntaxKind.JsxElement:
            case SyntaxKind.JsxSelfClosingElement:
            case SyntaxKind.JsxSpreadAttribute:
            case SyntaxKind.ExportAssignment:
            case SyntaxKind.ExportDeclaration:
            case SyntaxKind.ExportSpecifier:
            case SyntaxKind.ImportDeclaration:
            case SyntaxKind.ImportSpecifier:
            case SyntaxKind.ModuleDeclaration:
            case SyntaxKind.SourceFile:
            case SyntaxKind.VariableStatement:
            case SyntaxKind.TypeAliasDeclaration:
            case SyntaxKind.TypeParameter:
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.PropertyAssignment:
            case SyntaxKind.ShorthandPropertyAssignment:
            case SyntaxKind.SpreadAssignment:
                return true;
            default:
                return false;
        }
    }
}
